
% Introdução

\chapter{INTRODUÇÃO}

\begin{quote}
    I think of myself as an engineer, not as a visionary or 'big thinker.' I don't have any lofty goals.
    (Linus Torvalds)  
\end{quote}

A limitação do ser humano em captar, integralmente, os fenômenos ao seu redor é evidente, a ponto de não conseguir compreender como eles se dão; analisar um fenômeno, portanto, separando-o em pequenas partes (ou elementos) cujo comportamento já é conhecido (simplificado ou não), e, a partir da justaposição delas, reconstruir o funcionamento do próprio fenômeno, é um modo intuitivo que engenheiros e cientistas procedem em seus estudos, criando modelos matemáticos sobre a natureza \cite[p. 2]{Zin}.

Decorrente dessa limitação, a necessidade de se criar modelos matemáticos padronizados para a compreensão de fenômenos físicos se faz constante, tanto por permitir sua disseminação e comunicação, quanto por generalizar suas aplicações. A física se utiliza, fortemente, de modelos descritos por equações diferencias, e isso não é por acaso. Não é como se os físicos tivesses uma preferências sobre símbolos, ou que achassem elegante assim descrever seus modelos. Os físicos, os engenheiros e os cientistas no geral, utilizam-se de equações diferencias, simplesmente, porque, traduzindo suas observações e modelos nesses objetos matemáticos, a solução, ou seja a predição do fenômeno, pode ser obtida por métodos numéricos já bem consolidados, ou algebricamente em casos particulares. O MEF (Método dos Elementos Finitos) é um desses métodos numéricos: objeto de estudo desta dissertação, em que é aplicado à análise de tensão e deformação em estruturas sólidas sobre carregamentos estáticos em regime elástico linear.

O MEF consiste, basicamente, na ideia apresentada de análise, em que o domínio de uma equação diferencial é subdividido em elementos discretos, descritos por um conjunto de nós formando uma malha. Nesse método, os elementos tem suas propriedades herdadas do domínio (características, condições de contorno etc.), entretanto, a descrição do fenômeno é simplificada por meio de funções de interpolação, descritas pelas características de seus nós. Essas discretizações são, então, justapostas, de modo a garantir a continuidade, formando um sistema linear, cuja solução é uma aproximação da solução da própria equação diferencial. 

Esse procedimento é muito custoso em termos de cálculo, visto que para cada elementos é necessário calcular suas funções de interpolação, e depois justapor todos em um grande sistema linear, cuja solução também é custosa. É evidente, então, que o Método dos Elementos Finitos, ou os métodos numéricos em geral, acompanha o desenvolvimento da programação, impulsionado pelo avanço do processamento computacional \cite{Onate}. O poder computacional permite que se trabalhe com um volume inconcebível, para a capacidade humana, de dados e operações, como também das estruturas de dados e algoritmos que os manipulam. O algoritmo e a estrutura de dados passam a ser tão relevantes quanto a própria equação diferencial. Então, é de se esperar que uma aplicação desse método seja acompanhada de um projeto de software conciso, cujo objetivo não seja só a otimização computacional, mas a legibilidade e modularização.

A abordagem do tema na graduação de engenharia mecânica, porém, é focada, fortemente, na aplicação direta dos algoritmos, sem muita dedicação a assuntos relacionados à legibilidade e à estruturação de dados, o que pode ser devido, dentre outros aspectos, à falta de cadeiras abordando o desenvolvimento de aplicações, ou mesmo de programação como um todo. Com exceção de algumas propedêuticas, que ensinam introdução à lógica de programação em C++, a grade curricular do engenheiro mecânico não contempla o projeto de software, e, portanto, faz com que os discente, que queiram seguir em áreas mais computacionais, como simulação de fluidos, de estruturas ou análise de dados, tenham que estudar por conta, e, por decorrência disso, acabam desenvolvendo má práticas de programação, ou mesmo, não conseguem desenvolver aplicações de qualidade\footnote{Aplicação de qualidade, é definida aqui, tal como dito no capítulo \ref{ch:julia} \nameref{ch:julia}, como aquela desenvolvida por bons programadores, que visam a legibilidade e simplicidade do código. Nas palavras de \citeshort{fowler}: qualquer um pode escrever códigos que o computador compreenda, bons programadores escrevem códigos que humanos possam entender.}. 

Essas cadeiras de programação, pelo menos na perspectiva do aluno de graduação em engenharia mecânica na UDESC, ensinam ferramentas inapropriadas para suas necessidades acadêmicas. Hoje, Python e suas bibliotecas: Pandas, NumPy, CoolProp..., utilizando-se de sua sintaxe simplificada, tipagem dinâmica e popularidade (ocupando a TIOBE Index três vezes nos últimos cinco anos), para possibilitar o acesso facilitado a ferramentas de manipulação de dados (estatística e filtragem com Pandas), construção de modelos físicos (interpolações de propriedades termodinâmicas com CoolProp) e, principalmente, automatização de tarefas \cite{ernesti}. Em contra partida, seu desempenho, em termos de processamento, é muito inferior ao de linguagens compiladas, como C e Fortran, cuja eficiência de execução é necessária, quando se trabalha com problemas grandes e complexos, para se obter um tempo de execução razoável, as custas de uma sintaxe prolixa, tipagem estática e gerenciamento manual de memória. Esse dilema entre produtividade de linguagens como Python e o desempenho de linguagens como C, é conhecido como \emph{The Two languages Problem}, ou, em tradução livre, O Problema das Duas Linguagens.

Visando unificar esses dois mundos, e diminuir a distância entre as linguagens, engenheiros do MIT desenvolveram Julia, "a programming language for the scientific community that combines features of productivity languages, such as Python or MATLAB, with characteristics of performance-oriented languages, such as C++ or Fortran." \cite[tradução livre]{Bezanson} Por conta do sucesso de Julia, e de sua comunidade engajada, a linguagem vem sendo adotada mais e mais no âmbito acadêmico, incluindo na área de elementos finitos, o que motivou a escolha dela para o desenvolvimento deste trabalho.

O Método dos Elementos Finitos é uma ferramenta numérica poderosa para a análise de sólidos, e o seu desenvolvimento em linguagens como Julia oferece uma porta de entrada muito convidativa para novos engenheiros, assim como impulsiona novas pesquisas no campo. Entendendo como o método funciona e como é aplicado, observando aspectos tanto matemáticos e físicos, quanto de programação e de estrutura de dados, é crucial para que engenheiros possam aplicá-lo devidamente, principalmente quando se utilizam de soluções já prontas: de código-aberto ou proprietárias. Este documento aborda o desenvolvimento de um desses softwares: PHILLIPO.jl, cujo objetivo é expor e aplicar o MEF, abordando alguns aspectos de programação diferenciados daqueles vistos na graduação como programação paralela, modularização e empacotamento, sem o intuito concorrer com outras soluções já consolidadas ou ser referência de aplicação, mas de ser exemplificativo.

\section{Motivação}

O tema surgiu quando o autor se encontrou na tarefa de adicionar uma funcionalidade em um software já existente de elementos finitos, e percebeu que, mesmo tendo visto o assunto na graduação, não detinha o conhecimento necessário para compreender o seu funcionamento. Então resolveu por criar seu próprio programa, em Julia, aplicando seus conhecimento prévios de projeto de software, desenvolvendo mais o seu entendimento sobre o Método dos Elementos Finitos, assim como de aspectos numéricos computacionais.


\section{Objetivo}

O objetivo geral deste trabalho foi desenvolver uma aplicação de MEF para a análise de tensão e deformação em estruturas sólidas sobre carregamentos estáticos em regime elástico linear, utilizando para tanto, aspectos de programação funcional, processamento paralelo, focando em características modulares de implementação e de legibilidade, com o intuito secundário de expor das facilidades e vantagens da linguagem Julia, como também servir de exemplo menor.

\subsection{Objetivos propostos}

Foram propostos os seguintes objetivos específicos:

\begin{enumerate}
    \item estudar o MEF aplicado na determinação de deformações de estruturas sólidas em regime elástico e linear, sob carregamentos estáticos (implementando os elementos triangulares e tetraédricos, de deformações constantes);
    \item programar os algoritmos de MEF em Julia;
    \item desenvolver um módulo que seja distribuível pelo gerenciador de pacotes Pkg.jl, em um repositório público hospedado no GitHub;
    \item aplicar processamento paralelo em determinadas partes do programa em que as funções nativas não o fazem, a fim de utilizar mais da capacidade de processamento do computador que um código feito sobre o paradigma estruturado;
    \item estudar as características da linguagem Julia, e como ela pode ser uma alternativa viável para C e FORTRAN em programação científica de alta performance.
\end{enumerate}

\section{Organização do documento}

Este documento aborda o projeto e o desenvolvimento de um módulo em Julia, denominado PHILLIPO.jl, que aplica o Método de Elementos Finitos, integrado à ferramenta de pré e pós-processamento GiD, para realizar a análise das tensões em estruturas sólidas e elásticas sobre carregamentos estáticos; e é organizado em capítulos que abordam:

\begin{enumerate}
    \item A mecânica dos sólidos: tensão e deformação no regime elástico;
    \item O método de elementos finitos aplicado no equilíbrio estático de estruturas sólidas;
    \item A linguagem de programação Julia: o processamento paralelo acessível a engenheiros mecânicos;
    \item PHILLIPO.jl, o módulo;
    \item Validação e verificação de resultados;
    \item Objetivos alcançados e melhorias em projetos futuros;
    \item Conclusão.
\end{enumerate}

O código fonte de PHILLIPO.jl, sob a licença LGPL, assim como o das interfaces de integração com o GiD, estão impressas em anexos, cujos arquivos, incluindo o \LaTeX\ deste documento, podem ser acessados no repositório: \url{https://github.com/lucas-bublitz/PHILLIPO.jl}.