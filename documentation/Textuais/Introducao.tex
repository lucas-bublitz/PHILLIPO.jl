
% Introdução

\chapter{INTRODUÇÃO}

\begin{quote}
    I think of myself as an engineer, not as a visionary or 'big thinker.' I don't have any lofty goals.
    (Linus Torvalds)  
\end{quote}

A limitação do ser humano em captar integralmente os fenômenos ao seu redor é evidente, a ponto de não conseguir compreender como eles se dão. Analisar um fenômeno, portanto, separando-o em pequenas partes (ou elementos) cujo comportamento é mais facilmente determinado, e, a partir da justaposição delas, reconstruir o funcionamento do próprio fenômeno, é um modo intuitivo que engenheiros e cientistas procedem em seus estudos. \cite[p. 2]{Zin}.


[...]


O MEF consiste, basicamente, na ideia apresentada de análise, em que o domínio de uma equação diferencial é subdividido em elementos discretos, descritos por um conjunto de nós formando uma malha. Nesse método, os elementos tem suas propriedades herdadas do domínio (características, condições de contorno etc.), porém, a descrição do fenômeno é simplificada por meio de funções de interpolação. Essas discretizações são, então, justapostas sobre os nós da malha, de modo a garantir continuidade, formando um sistema de equações algébricas, cuja solução é uma aproximação da solução da própria equação diferencial. \cite[pág. 1 e 2]{LIU}

Esse procedimento é muito custoso em termos de cálculo, visto que para cada elementos é necessário calcular suas funções de interpolação, e depois justapor todos em um grande sistema de equações algébricas, cuja solução também é custosa. É evidente, então, que o Método dos Elementos Finitos, ou os métodos numéricos em geral, acompanha o desenvolvimento da programação, impulsionado pelo avanço do processamento computacional \cite{Onate}. O poder computacional permite que se trabalhe com um volume inconcebível, para a capacidade humana, de dados e operações, como também das estruturas de dados e algoritmos que os manipulam. O algoritmo e a estrutura de dados passam a ser tão relevantes quanto a própria equação diferencial. Então, é de se esperar que uma aplicação desse método seja acompanhada de aspectos de projeto de software conciso, cujo objetivo não seja só a otimização computacional, mas a legibilidade e modularização, que são características úteis quando se espera a reutilização, aprimoramento continuado e, acima de tudo, a comunicação do código-fonte.

A escolha da linguagem de programação, então, para uma aplicação do MEF, é o passo fundamental para se planejar a estrutura do código, pois, são as ferramentas de sintaxe e processamento que a linguagem e seu compilador/interpretador oferecem que vão ditar, em parte, a forma como os algoritmos são implementados, além de outros aspectos de execução, como otimização e estrutura de dados. Comumente, esses softwares de análise por elementos finitos, como Abaqus e Ansys, são escritos em linguagens compiladas, basicamente, C e FORTRAN, que são sinônimos de robustez e desempenho. Entretanto, também são conhecidas pela sua prolixidade, complexidade de sintaxe de distribuição de bibliotecas, empacotamento... Elas não se mostram mais atrativas para se desenvolver, com praticidade, não só aplicações do MEF, como também a maioria das aplicações práticas na vida dos engenheiros e cientistas (automatização de tarefas, análise de dados e até computação algébrica simbólica). Hoje, Python e suas bibliotecas: Pandas, NumPy, CoolProp... utilizando-se de sua sintaxe de sua sintaxe simplificada, tipagem dinâmica e popularidade (ocupando o TIOBE Index três vezes nos últimos cinco anos), possibilita o acesso a ferramentas muito sofisticas: manipulação de dados (estatística e filtragem com Pandas), construção de modelos físicos (interpolação de propriedades termodinâmicas com CoolProp) e automatização de tarefas. \cite{ernesti} Porém, toda essa conveniência tem um preço: o desempenho.

É notável que linguagens interpretadas, como Python, tem desempenho, em termos de processamento, muito inferior ao de linguagens compiladas, como C e Fortran, cuja eficiência de execução é necessária, quando se trabalha com problemas grandes e complexos, para se obter um tempo de execução razoável, às custas de uma sintaxe prolixa, tipagem estática e gerenciamento manual de memória. Esse dilema entre a produtividade de linguagens como Python e o desempenho de linguagens como C, é conhecido como \emph{The Two languages Problem}, ou, em tradução livre, O Problema das Duas Linguagens.

Visando unificar esses dois mundos, e diminuir a distância entre as linguagens, engenheiros do MIT desenvolveram Julia, "a programming language for the scientific community that combines features of productivity languages, such as Python or MATLAB, with characteristics of performance-oriented languages, such as C++ or Fortran." \cite[tradução livre]{Bezanson} Por conta do sucesso de Julia, e de sua comunidade engajada, a linguagem vem sendo adotada mais e mais no âmbito acadêmico, incluindo na área de elementos finitos, o que motivou a escolha dela para o desenvolvimento deste trabalho.

O Método dos Elementos Finitos é uma ferramenta numérica poderosa para a análise de sólidos, e o seu desenvolvimento em linguagens como Julia oferece uma porta de entrada muito convidativa para novos engenheiros, assim como impulsiona novas pesquisas no campo. Entendendo como o método funciona e como é aplicado, observando aspectos tanto matemáticos e físicos, quanto de programação e de estrutura de dados, é crucial para que engenheiros possam aplicá-lo devidamente, principalmente quando se utilizam de soluções já prontas: de código-aberto ou proprietárias. Este documento aborda o desenvolvimento de um desses softwares: PHILLIPO.jl, cujo objetivo é expor e aplicar o MEF, abordando alguns aspectos de programação diferenciados daqueles vistos na graduação, como programação paralela, modularização e empacotamento, sem o intuito de concorrer com outras soluções já consolidadas ou ser referência de aplicação, mas de ser exemplificativo.

\section{Motivação}

O tema surgiu quando o autor se encontrou na tarefa de adicionar uma funcionalidade em um software já existente de elementos finitos, e, já visto uma introdução ao assunto na graduação, teve o interesse de se aprofundar. Então resolveu por criar seu próprio programa, em Julia, aplicando seus conhecimento prévios de projeto de software, desenvolvendo mais o seu entendimento sobre o Método dos Elementos Finitos, assim como de aspectos numéricos computacionais.


\section{Objetivo}

O objetivo geral deste trabalho foi desenvolver uma aplicação de MEF para a análise de tensão e deformação em estruturas sólidas sobre carregamentos estáticos em regime elástico linear, utilizando para tanto, aspectos de programação funcional, processamento paralelo, focando em algumas características modulares de implementação e de legibilidade, com o intuito secundário de expor as facilidades e vantagens da linguagem Julia, como também servir de exemplo menor.

\subsection{Objetivos propostos}

Foram propostos os seguintes objetivos específicos:

\begin{enumerate}
    \item estudar o MEF aplicado na determinação de deformações de estruturas sólidas em regime elástico e linear, sob carregamentos estáticos (implementando os elementos triangulares e tetraédricos, de deformações constantes);
    \item programar os algoritmos de MEF em Julia;
    \item desenvolver um módulo que seja distribuível pelo gerenciador de pacotes Pkg.jl, em um repositório público hospedado no GitHub;
    \item aplicar processamento paralelo em determinadas partes do programa em que as funções nativas não o fazem, a fim de utilizar mais da capacidade de processamento do computador que um código feito sobre o paradigma estruturado;
    \item estudar as características da linguagem Julia, e como ela pode ser uma alternativa viável para C e FORTRAN em programação científica de alta performance.
\end{enumerate}

\section{Organização do documento}

Este documento aborda o projeto e o desenvolvimento de um módulo em Julia, denominado PHILLIPO.jl, que aplica o Método de Elementos Finitos, integrado à ferramenta de pré e pós-processamento GiD, para realizar a análise das tensões em estruturas sólidas e elásticas sobre carregamentos estáticos; e é organizado em capítulos que abordam:

\begin{enumerate}
    \item A mecânica dos sólidos: tensão e deformação no regime elástico;
    \item O método de elementos finitos aplicado no equilíbrio estático de estruturas sólidas;
    \item A linguagem de programação Julia: o processamento paralelo acessível a engenheiros mecânicos;
    \item PHILLIPO.jl, o módulo;
    \item Validação e verificação de resultados;
    \item Objetivos alcançados e melhorias em projetos futuros;
    \item Conclusão.
\end{enumerate}

O código fonte de PHILLIPO.jl, sob a licença LGPL, assim como o das interfaces de integração com o GiD, estão impressas em anexos, cujos arquivos, incluindo o \LaTeX\ deste documento, podem ser acessados no repositório: \url{https://github.com/lucas-bublitz/PHILLIPO.jl}.

Todas as figuras foram criadas pelo próprio autor.